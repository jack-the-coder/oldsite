---
layout: post
title:  "What's your goal? / Beating the Averages returns"
date:   2019-07-27 15:52:57 -0500
hidden: true
categories: philosophy
---

If you're reading this, you probably live in a bubble. 

Nobody cares that you wrote your latest web application in this week's trendiest frontend framework. New programmers (probably) don't search the web to compare Haskell and Common Lisp; they go straight to the "Top 10 Best Paying Programming Languages (2019)" or "Hot Technologies for 2019" listicles. 

While diving deep into "difficult" programming languages, hacker culture, category theory, or obscure operating systems may be mentally rewarding, it almost certainly doesn't pay the bills or achieve other external goals. No amount of Emacs tinkering or mechanical keyboard modification is going to impress non-technical employers. 

At the same time, money doesn't buy happiness. There is certainly something to be said for finding a job that is enjoyable and feels rewarding, even if it doesn't pay as much as the alternatives. Given that each extreme is unfavorable, it's obvious that striking a balance is necessary for finding maximum enjoyment in life. 

The trouble with the "mental reward" route is that it encourages a "holier than thou" attitude---something that doesn't do anyone any favors. While it's easier to branch further and further from the mainstream, finding interesting ideas lost to time (like Lisp Machines or even completely analog computers), this attitude makes it hard to come back to the world that practically everyone else lives in, where these ideas are useless unless they make money. 

Another way of thinking that some people take is to use their knowledge of relatively obscure technologies and apply it as a competitive advantage to business. While Paul Graham's "Beating the Averages" reeks of survivorship bias, the underlying concept certainly could apply favorably to both monetary and metal satisfaction. And although using Common Lisp probably doesn't make nearly as much of a positive contribution to the success of a modern SaaS startup as it did back then (especially since dynamic and scripting languages are very popular for that task nowadays), finding and exploiting a competitive advantage that comes from little-used technology is still a viable option. 

## Selection
A good mix of stimulation and practicality sounds like the right choice for a fresh startup's technology stack. However, different markets surrounding startups make the optimal spot on this continuum different for each company. For instance, marketing an application to make a particular profession's practices more efficient probably doesn't require fancy-pants technology; milking a small niche with little to no competition can be very profitable. In other industries, where there is fierce competition between relatively similar products, using obscure but powerful technology can make a huge difference. 

This type of space is what Paul Graham's Viaweb famously broke into. They had so much more productivity than their competitors that they were able to out-innovate much larger companies that had huge teams of programmers. Since Viaweb's labor costs were so much lower, their margins were significantly higher than the competition. 

Today, the issue is that everyone else has caught on to the fact that writing web applications in C++ is not efficient (although many seemingly haven't found out the same about Java). To compete in a similar field nowadays, you need more than just a dynamically-typed programming language (not that that's all that Lisp is) and a couple of expert programmers. 

The timeless part of Graham's essay is that startups need to be doing something fundamentally different to survive in a competitive environment. Simply doing what everyone else is completely useless. 

In 2019, what "everyone else" is doing (at least in the startup field) differs widely. Using Rails instead of Django or even a SPA instead of server-side templating doesn't make a huge difference to the average startup's efficiency. While the average programming language (like Ruby, Python, or JavaScript) has increased significantly in power from the average in the late 90s, it hasn't reached the peaks reached by languages like Lisp and Haskell. At the same time, a programmer new to both languages would probably find Python much easier to wrap their head around than Haskell, especially for web applications where Python has a much larger share of libraries and frameworks. This makes a huge difference in hiring (and getting hired), although easier-to-learn languages (or those taught in schools) attract lower-quality candidates. 

---

In conclusion, there's no right answer for the ultimate technology to use for building a startup, let alone the correct choice for optimizing life satisfaction. All that truly matters is not losing sight of the goal, whether that be intellectual stimulation, financial success, some mix of the two, or something else entirely. 
